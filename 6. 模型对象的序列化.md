# 6. 模型对象的序列化

### 1.理解序列化时的default函数

我们最想做的一件事情，就是在视图函数中，读取出模型之后，还要把他的属性读出来，转换成一个字典。我们想直接```jsonfiy(user)```

现在jsonfiy并不能直接序列化对象，所以我们的目标就是必须想办法让jsonfiy直接序列化对象。

jsonfiy在序列化对象的时候，如果不知道如何序列化当前传进来的参数，就会去调用JSONEncoder类的default函数。

```python
    def default(self, o):
        """Implement this method in a subclass such that it returns a
        serializable object for ``o``, or calls the base implementation (to
        raise a :exc:`TypeError`).

        For example, to support arbitrary iterators, you could implement
        default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                return JSONEncoder.default(self, o)
        """
        if isinstance(o, datetime):
            return http_date(o.utctimetuple())
        if isinstance(o, date):
            return http_date(o.timetuple())
        if isinstance(o, uuid.UUID):
            return str(o)
        if hasattr(o, '__html__'):
            return text_type(o.__html__())
        return _json.JSONEncoder.default(self, o)
```

目前的default是没有提供对对象的序列化的，所以我们这里最关键的就是要重写default方法。在重写的过程中实现对对象的序列化就可以了

### 2.不完美的对象转字典

我们首先要做到的就是让Flask可以调用到我们自己定义的default函数。要做到这一点，我们需要继承JSONEncoder，然后重写defualt方法，然后继承Flask，在子类里，替换掉Flask原有的json_encoder对象。然后，是实例化Flask核心对象的时候，使用我们的子类进行实例化

```python
class JSONEncoder(_JSONEncoder):

    def default(self, o):
        # 只能转换实例变量
        return o.__dect__


class Flask(_Flask):
    json_encoder = JSONEncoder()
```

上面的写法o.\_\_dect__只能转换实例变量，不能讲类变量也转换成字典。


### 3.深入理解dict机制

在Python中创建一个dict有很多种方式:

1. 直接定义一个字典
```python
r = {
    'name': 'gwf'
}
```

2. 使用dict函数
```python
r = dict(name='gwf')
```

3. 将一个对象传入dict函数
值得研究的是这第三种方法，当将一个对象传入dict函数的时候，他会去调用keys函数
![image.png](https://upload-images.jianshu.io/upload_images/7220971-4a99949baa0f298e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

keys 方法的目的就是为了拿到字典里所有的键，至于说这些键有那么，完全有我们自己来定义。keys 返回的必须是一个元组或者列表来声明要序列化的键。

而dict会以中括号的形式来拿到对应的值，如o["name"]，但是默认是不能这么访问的，我们需要编写\_\_getitem__函数


```python
class Person:
    name = 'gwf'
    age = 18

    def __init__(self):
        self.gender = 'male'

    def keys(self):
        return ('name', 'age', 'gender')

    def __getitem__(self, item):
        return getattr(self, item)


o = Person()
print(dict(o))
# {'name': 'gwf', 'age': 18, 'gender': 'male'}
```

这样我们就成功的讲一个对象转化成了字典的形式，并且无论类变量和实例变量，都可以转化，更加灵活的是，我们可以自己控制，那些变量需要转化，哪些变量不需要转化

> 注意：



