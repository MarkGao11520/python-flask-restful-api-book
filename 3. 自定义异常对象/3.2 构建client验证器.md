# 3.2 注册client

对于登录/注册这些比较重要的接口，我们建议提供一个统一的调用接口，而不应该拆分成多个。

我们可以编写一个枚举类，来枚举所有的客户端类型。


### 1.构建client验证器
```python
class ClientForm(Form):
    account = StringField(validators=[DataRequired(), length(
        min=1, max=32
    )])
    secret = StringField()
    type = IntegerField(validators=[DataRequired()])

    # 验证client_type
    def validate_type(self, value):
        try:
            # 将用户传来的参数去枚举类中匹配，如果匹配失败，则抛出异常
            # 如果匹配成功则将int转换成枚举
            client = ClientTypeEnum(value.data)
        except ValueError as e:
            raise e
```


### 2.处理不同客户端注册的方案
由于python没有switch-case，我们可以使用dict来替换
```python
@api.route('/register')
def create_client():
    # request.data用来接收json类型的参数
    data = request.data
    # 关键字参数data是wtform中用来接收json参数的方法
    form = ClientForm(data=data)

    if form.validate():
        # 替代switchcase-{Enum_name:handle_func}
        promise = {
            ClientTypeEnum.USER_EMAIL: __register_user_by_email
        }
```

### 3.用户模型的设计
```python
class User(Base):
    id = Column(Integer, primary_key=True)
    email = Column(String(50), unique=True, nullable=False)
    auth = Column(SmallInteger, default=1)
    nickname = Column(String(24), nullable=False)
    _password = Column('password', String(128))

    @property
    def password(self):
        return self._password

    @password.setter
    def password(self, raw):
        self._password = generate_password_hash(raw)

    # 从面向对象的角度考虑，在一个对象中创建一个对象本身这个是不合理的。
    # 但是如果将他声明为一个静态方法，那么就是合理的
    @staticmethod
    def register_by_email(nikename, account, secert):
        with db.auto_commit():
            user = User()
            user.nickname = nikename
            user.email = account
            user.password = secert
            db.session.add(user)
```